name:           ADPfusion
version:        0.4.0.0
author:         Christian Hoener zu Siederdissen, 2011-2014
copyright:      Christian Hoener zu Siederdissen, 2011-2014
homepage:       http://www.bioinf.uni-leipzig.de/~choener/adpfusion
maintainer:     choener@bioinf.uni-leipzig.de
category:       Algorithms, Data Structures, Bioinformatics
license:        BSD3
license-file:   LICENSE
build-type:     Simple
stability:      experimental
cabal-version:  >= 1.8.0
synopsis:
                Efficient, high-level dynamic programming.
description:
                ADPfusion combines stream-fusion (using the stream interface
                provided by the vector library) and type-level programming to
                provide highly efficient dynamic programming combinators.
                .
                This library is described in:
                .
                @
                Christian Hoener zu Siederdissen
                Sneaking Around ConcatMap: Efficient Combinators for Dynamic Programming
                2012. Proceedings of the 17th ACM SIGPLAN international conference on Functional programming
                <http://doi.acm.org/10.1145/2364527.2364559> preprint: <http://www.tbi.univie.ac.at/newpapers/pdfs/TBI-p-2012-2.pdf>
                @
                .
                Additional optimizations learned from the paper below have been integrated:
                .
                @
                Andrew Farmer, Christian Höner zu Siederdissen, and Andy Gill.
                The HERMIT in the stream: fusing stream fusion’s concatMap.
                2014. Proceedings of the ACM SIGPLAN 2014 workshop on Partial evaluation and program manipulation.
                <http://dl.acm.org/citation.cfm?doid=2543728.2543736>
                @
                .
                From the programmers' viewpoint, ADPfusion behaves very much
                like the original ADP implementation
                <http://bibiserv.techfak.uni-bielefeld.de/adp/> developed by
                Robert Giegerich and colleagues, though both combinator
                semantics and backtracking are different.
                .
                The library internals, however, are designed not only to speed
                up ADP by a large margin (which this library does), but also to
                provide further runtime improvements by allowing the programmer
                to switch over to other kinds of data structures with better
                time and space behaviour. Most importantly, dynamic programming
                tables can be strict, removing indirections present in lazy,
                boxed tables.
                .
                As a simple benchmark, consider the Nussinov78 algorithm which
                translates to three nested for loops (for C). In the figure,
                four different approaches are compared using inputs with size
                100 characters to 1000 characters in increments of 100
                characters. "C" is an implementation (@./C/@ directory) in "C"
                using "gcc -O3". "ADP" is the original ADP approach (see link
                above), while "GAPC" uses the "GAP" language
                (<http://gapc.eu/>).
                .
                Performance comparison figure:
                <http://www.bioinf.uni-leipzig.de/~choener/adpfusion/gaplike-nussinov-runtime.jpg>
                .
                Please note that actual performance will depend much on table
                layout and data structures accessed during calculations, but in
                general performance is very good: close to C and better than
                other high-level approaches (that I know of).
                .
                .
                .
                Even complex ADP code tends to be completely optimized to loops
                that use only unboxed variables (Int# and others,
                indexIntArray# and others).
                .
                Completely novel (compared to ADP), is the idea of allowing
                efficient monadic combinators. This facilitates writing code
                that performs backtracking, or samples structures
                stochastically, among others things.
                .
                .
                .
                Two algorithms from the realm of computational biology are
                provided as examples on how to write dynamic programming
                algorithms using this library:
                <http://hackage.haskell.org/package/Nussinov78> and
                <http://hackage.haskell.org/package/RNAFold>. In addition, this
                library comes with three examples in the ADP/Fusion/Examples/
                directory. They are built if @-fexamples@ is set during
                configuration.



Extra-Source-Files:
  README.md
  changelog.md

flag examples
  description:  build the examples
  default:      False
  manual:       True

flag llvm
  description:  build using LLVM
  default:      False
  manual:       True

library
  build-depends:
    mmorph            == 1.0.*    ,
    monad-primitive   == 0.1      ,
    mtl               == 2.*      ,
    primitive         == 0.5.*    ,
    PrimitiveArray    == 0.6.*    ,
    QuickCheck        == 2.*      ,
    repa                          ,
    strict            == 0.3.*    ,
    template-haskell  == 2.*      ,
    transformers      == 0.3.*    ,
    tuple             == 0.3.*    ,
    vector            == 0.10.*   ,
    base              == 4.*
  exposed-modules:
    ADP.Fusion
    ADP.Fusion.Apply
    ADP.Fusion.Chr
    ADP.Fusion.Classes
    ADP.Fusion.Empty
    ADP.Fusion.Multi
    ADP.Fusion.Multi.Classes
--    ADP.Fusion.Multi.Empty
--    ADP.Fusion.Multi.GChr
--    ADP.Fusion.Multi.None
    ADP.Fusion.None
--    ADP.Fusion.QuickCheck
--    ADP.Fusion.Region
    ADP.Fusion.Table
    ADP.Fusion.Table.Array
    ADP.Fusion.Table.Axiom
    ADP.Fusion.Table.Backtrack
    ADP.Fusion.Table.Fill
    ADP.Fusion.Table.Indices
    ADP.Fusion.Table.Recursive
    ADP.Fusion.TH

  ghc-options:
    -O2 -funbox-strict-fields

executable NeedlemanWunsch
  if flag(examples)
    buildable:
      True
    build-depends:
      ADPfusion       ,
      primitive       ,
      PrimitiveArray  ,
      vector          ,
      base
  else
    buildable:
      False
  hs-source-dirs:
    src
  main-is:
    NeedlemanWunsch.hs
  ghc-options:
    -Odph
    -funbox-strict-fields
    -funfolding-use-threshold1000
    -funfolding-keeness-factor1000
  if flag(llvm)
    ghc-options:
      -fllvm
      -optlo-O3 -optlo-std-compile-opts
      -fllvm-tbaa

executable Nussinov
  if flag(examples)
    buildable:
      True
    build-depends:
      ADPfusion         ,
      PrimitiveArray    ,
      template-haskell  ,
      vector            ,
      base
  else
    buildable:
      False
  hs-source-dirs:
    src
  main-is:
    Nussinov.hs
  ghc-options:
    -O2
    -funbox-strict-fields
    -funfolding-use-threshold1000
    -funfolding-keeness-factor1000
  if flag(llvm)
    ghc-options:
      -fllvm
      -optlo-O3 -optlo-std-compile-opts
      -fllvm-tbaa

executable TwoNussinov
  if flag(examples)
    buildable:
      True
    build-depends:
      ADPfusion         ,
      PrimitiveArray    ,
      template-haskell  ,
      vector            ,
      base
  else
    buildable:
      False
  hs-source-dirs:
    src
  main-is:
    TwoNussinov.hs
  ghc-options:
    -O2
    -funbox-strict-fields
    -funfolding-use-threshold1000
    -funfolding-keeness-factor1000
  if flag(llvm)
    ghc-options:
      -fllvm
      -optlo-O3 -optlo-std-compile-opts
      -fllvm-tbaa

executable MemoRecNussinov
  if flag(examples)
    buildable:
      True
    build-depends:
      ADPfusion         ,
      PrimitiveArray    ,
      template-haskell  ,
      vector            ,
      base
  else
    buildable:
      False
  hs-source-dirs:
    src
  main-is:
    MemoRecNussinov.hs
  ghc-options:
    -O2
    -funbox-strict-fields
    -funfolding-use-threshold1000
    -funfolding-keeness-factor1000
  if flag(llvm)
    ghc-options:
      -fllvm
      -optlo-O3 -optlo-std-compile-opts
      -fllvm-tbaa

executable Durbin
  if flag(examples)
    buildable:
      True
    build-depends:
      ADPfusion         ,
      PrimitiveArray    ,
      template-haskell  ,
      vector            ,
      base
  else
    buildable:
      False
  hs-source-dirs:
    src
  main-is:
    Durbin.hs
  ghc-options:
    -Odph
    -fcpr-off
    -funbox-strict-fields
    -funfolding-use-threshold1000
    -funfolding-keeness-factor1000
  if flag(llvm)
    ghc-options:
      -fllvm
      -optlo-O3 -optlo-std-compile-opts
      -fllvm-tbaa

executable DishonestCasino
  if flag(examples)
    buildable:
      True
    build-depends:
      ADPfusion                   ,
      cmdargs           == 0.10.* ,
      log-domain        == 0.9.*  ,
      mwc-random        == 0.13.* ,
      mwc-random-monad  == 0.7.*  ,
      PrimitiveArray              ,
      template-haskell            ,
      vector                      ,
      base
  else
    buildable:
      False
  hs-source-dirs:
    src
  main-is:
    DishonestCasino.hs
  ghc-options:
    -Odph
    -fcpr-off
    -funbox-strict-fields
    -funfolding-use-threshold1000
    -funfolding-keeness-factor1000
  if flag(llvm)
    ghc-options:
      -fllvm
      -optlo-O3 -optlo-std-compile-opts
      -fllvm-tbaa

source-repository head
  type: git
  location: git://github.com/choener/ADPfusion

